package main

import (
	"fmt"
)

/* ВАЖНО!!!
Необходимо запомнить, что в качестве второго значения range возвращает копию элемента массива,
это может быть важно, если в цикле мы хотим изменить массив.
В этом случае мы должны обращаться к элементам массива по индексу:
*/

func main() {
	a := [5]int{1, 2, 3, 4, 5}
	fmt.Println(a) // [1 2 3 4 5]

	for _, elem := range a {
		elem = 100
		fmt.Println(elem)
		// 100
		// 100
		// 100
		// 100
		// 100
	}
	fmt.Println(a) // [1 2 3 4 5]

	for idx := range a {
		a[idx] = 100
		fmt.Println(a[idx])
		// 100
		// 100
		// 100
		// 100
		// 100
	}
	fmt.Println(a) // [100 100 100 100 100]
	arr()
}

func arr() {
	a := [4]int{1, 2, 3, 4}
	for ind := range a {
		fmt.Printf("%d \n", a[ind]) // 1 2 3 4
	}

	// Заданный фиксированный размер
	//	a := [3]int{1,2,3}
	// Литерал массива с длиной, определяемой механизмом вывода типов
	//	a := [...]int{1,2,3}

	// Важно!!!  Копии массивов ссылаются на различные опорные данные.
	//При использовании массива в качестве параметров функции функция внутри принимает вместо исходного массива его копию.
	//Это поведение отличается от поведения, характерного для других языков, в которых массивы передаются по ссылке неявно.

	// в данном случае изменение не затрагивает массив  a:=[4]int{1, 2, 3, 4}
	b := a
	b[0] = 8
	fmt.Println(a) // [1 2 3 4]
	fmt.Println(b) // [8 2 3 4]

	// происходит изменение в массиве а в результате обращения к участку памяти массива
	c := &a
	c[0] = 9
	fmt.Println(a) //[9 2 3 4]

}

/*
Представьте, что существует способ преодолеть преграды пространства и времени,
что позволяет объединять миры и путешествовать в мгновение ока? Использование стандартной библиотеки Go в совокупности
с некоторой изобретательностью позволяет функции hyperspace из Листинга 4 модифицировать срез worlds,
убрав отступы между мирами разных планет.

import (
"fmt"
"strings"
)

// hyperspace убирает отступы между мирами планет
func hyperspace(worlds []string) { // Данный аргумент является срезом, а не массивом
	for i := range worlds {
		worlds[i] = strings.TrimSpace(worlds[i])
	}
}

func main() {
	planets := []string{" Венера   ", "Земля  ", " Марс"} // Планеты, разделенные друг от друга пробелами
	hyperspace(planets)

	fmt.Println(strings.Join(planets, "")) // Выводит: ВенераЗемляМарс
}
*/

/*

											Срез

    В срезе не хранится никаких данных, им лишь описывается раздел опорного массива, которым срез поддерживается.

    Встроенная функция len возвращает количество элементов в срезе.

	Встроенная функция cap возвращает длину опорного массива.

    Стили объявления:
// срез имеющегося массива
a := [...]int{1,2,3,4,5,6}
b := a[:3]
// стиль литерала
c := []int{1,2,3,4,5,6}
// с помощью функции «make»
d := make([]int, 10, 100)   // срез длиной и объемом length==10 capacity==100 соответственно
e := make([]int, 10)   // срез длиной и объемом length==10 capacity==10 соответственно


										Ассоциативный массив


В Go ассоциативный массив представляет собой ссылку на хеш-таблицу.
Это набор элементов, которые объединены в пары вида «ключ — значение».

		Стили объявления:
// стиль литерала
p := map[string]int{
    "Key1": 1,
    "Key2": 2,
  }
// с помощью функции «make»
q := make(map[string]int)
q["key3"] = 4
Чтобы узнать, присутствовал элемент или нет, используем такую проверку:
value, ok := p["Key2"]

Множественные присваивания ссылаются на одни и те же опорные данные.



*/
