package main

import (
	"bufio"
	"io"
	"os"
	"strconv"
)

/*
bufio vs fmt
Ранее в рамках этого курса при решении задач требовалось прочитать что-то со стандартного ввода и вывести результат соответственно в стандартный вывод.
При этом кто-то использовал пакет fmt, а кто-то - bufio + os. Все эти пакеты имеют свои особенности, поэтому в этой задаче мы попробуем решить знакомую нам проблему с помощью пакетов,
которые кто-то мог до этого момента и не применять: bufio + os + strconv.
Задача состоит в следующем: на стандартный ввод подаются целые числа в диапазоне 0-100, каждое число подается на стандартный ввод с новой строки (количество чисел не известно).
Требуется прочитать все эти числа и вывести в стандартный вывод их сумму.
Несколько подсказок: для чтения вы можете использовать типы bufio.Reader и bufio.Scanner, а для записи - bufio.Writer. При чтении помните об ошибке io.EOF.
Конвертирование данных из строки в целое число и обратно осуществляется функциями Atoi и Itoa из пакета strconv соответственно. Чтение производится из стандартного ввода (os.Stdin),
а запись - в стандартный вывод (os.Stdout).
Все указанные в тексте задачи пакеты (strconv, bufio, os, io), уже импортированы (другие использовать нельзя), package main объявлен.
Sample Input:
33
47
12
79
15
Sample Output:
186
*/
func main() {
	num := 0
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		txt := scanner.Text()
		convernnum, _ := strconv.Atoi(txt)
		num = num + convernnum
	}
	s := strconv.Itoa(num)
	io.WriteString(os.Stdout, s)
}

/*
					в Go пользовательский ввод можно считать несколькими способами:

Пакет fmt
"fmt" — реализует форматированный ввод-вывод с аналогичными функциями в Cи
// Это принтэфы сканэфы. В большинстве случаев его достаточно. Даже в production, редки случаи когда нужно что-либо остальное

// Ввод соответственно выглят так

var text string
fmt.Scan(&string) // & амперсанд перед переменной обязательно!

// Ввод в цикле:

var word string
for i:=0; i < 5; i++ {
fmt.Scan(&word)
fmt.Println(word) // Печатем, чтобы посмотеть что только. Что ввели.
}
Но минус, как я понимаю, пакета "fmt" в том, вы будете смеятся он медленный (для ввода, хотя с этим от версии к версии языка борются,
вроде что-то в 1.17 писали в патчноуте в 1.18 не смотрел). Но из-за удобства я предпочитаю использовать его.

									Пакет os

"os" — предоставляет независимый от платформы интерфейс к функциям операционной системы. Т.е. мы можем использовать потоки ввода/вывода.
Т.е. мы можем считывать ввод. // Подробнее рассматривается в курсах Linux.

// Из него нам требуется объект os.Stdin, который позволяет считывать данные с консоли.
Пакет buffio

// Как писал выше "fmt" работет медлинно и чтобы это пофиксить используют буфер —
// некоторая промежуточная область в оперативной памяти выделяется, в которой постепенно
// накапливается информация. В подробности не вдаёмся

"buffio" — собственно и реализует буферизованный ввод-вывод.


// В пакете buffio есть два метода
// Scanner и Reader

// Scanner используются при чтении построчно. Может использовать регулярки! И если не fmt, то используется чаще всего.
И наверное важно отметить Что он не копирует считываемую строку, при каждом вызове Scan она становится удаляется.

// Reader помимо чтения, добавляет буферизацию. Возвращает []byte т.е. используется для чтения байтов. И в свою очередь строка всегда будет скопирована.
buffio Scanner

// Т.о. для считывания строки с помощью сканера:
// Мы создаем новый объект сканнер, аргументом которому передаем потток ввода.
scanner := bufio.NewScanner(os.Stdin)
// Теперь у нас появляется возможность "слушать" ввод:
scanner.Scan() // возвращает true, пока файл не будет прочитан до конца
// И для передачи того что в потоке в переменую мы преабразовываем это дело в текст
s := scanner.Text()


// Аналогичное в цикле
for scanner.Scan() { // возвращает true, пока файл не будет прочитан до конца
txt := scanner.Text()
}


Вывод с помощью "зеркального" метода на запись
io.WriteString(os.Stdout, txt)
buffio Reader



reader := bufio.NewReader(os.Stdin)

for {
line, -, err := reader.ReadLine() // ReadLine возвращает line []byte, isPrefix bool, err error
if err == io.EOF {
break
}

txt, _ := string(line) // Конвертируем байты в строку. Эскейпим ошибку, лень обрабатывать.
// Для числа, мы бы делали так:
// num, _ := strconv.Atoi(string(line))
}

// Или

for {
s, err := rd.ReadString('\n')
if err == io.EOF {
break
}
...
}

// Вывод

writer := bufio.NewWriter(os.Stdout)
w.WriteString(txt) // Записываем строку
w.Flush() // При выполнении методов WriteString(), WriteRune(), WriteByte() и вы не поверите Write();
// данные вначале накапливаются в буфере, а чтобы сбросить их в источник данных,
// необходимо вызвать метод Flush().*/
